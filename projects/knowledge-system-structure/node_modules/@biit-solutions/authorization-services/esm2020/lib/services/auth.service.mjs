import { User } from "../models/user";
export class AuthService {
    constructor(rootPath, httpClient) {
        this.rootPath = rootPath;
        this.httpClient = httpClient;
    }
    getAll() {
        return this.httpClient.get(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/register`);
    }
    add(user) {
        return this.httpClient.post(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/register`, user);
    }
    update(request) {
        return this.httpClient.patch(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/register`, request);
    }
    login(request) {
        return this.httpClient.post(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/public/login`, request, { observe: 'response' });
    }
    changePassword(request) {
        return this.httpClient.post(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/password`, request);
    }
    getRoles() {
        return this.httpClient.get(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/roles`);
    }
    deleteByUserName(username) {
        return this.httpClient.delete(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/register/${username}`);
    }
    cancelAutoRenew() {
        clearTimeout(this.timeoutId);
    }
    loginByToken(token) {
        return this.httpClient.get(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/public/login/tokens/${token}`, { observe: 'response' });
    }
    autoRenewToken(token, expiration, tokenRenewListener, tolerance = AuthService.TOLERANCE) {
        if (this.timeoutId != null) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        const expirationDate = new Date(expiration);
        const now = new Date();
        const expirationTime = expirationDate.getTime() - AuthService.TOLERANCE - now.getTime();
        this.setTimeoutRenew(token, expirationTime, tokenRenewListener, tolerance);
        console.log(`Next token renew on: ${expirationDate}`);
    }
    setTimeoutRenew(token, timeout, tokenRenewListener, tolerance) {
        if (isNaN(timeout)) {
            console.error(`Timeout should be a number and received '${timeout}'`);
            return;
        }
        if (timeout < AuthService.MIN_WAIT_TIME) {
            timeout = AuthService.MIN_WAIT_TIME;
        }
        this.timeoutId = setTimeout(() => {
            this.renew(token).subscribe({
                next: (res) => {
                    if (!res) {
                        console.error('Server returned invalid response');
                        return;
                    }
                    const authToken = res.headers.get('authorization');
                    const expiration = Number(res.headers.get('expires'));
                    const user = User.clone(res.body);
                    if (!authToken || !expiration) {
                        throw new Error('Server returned invalid response');
                    }
                    if (isNaN(expiration)) {
                        throw new Error('Server returned invalid expiration time');
                    }
                    console.log(`Next token renew on: ${new Date(expiration)}`);
                    tokenRenewListener.onTokenReceived(authToken, expiration, user);
                    const newTimeOut = expiration - new Date().getTime() - tolerance;
                    this.setTimeoutRenew(authToken, newTimeOut, tokenRenewListener, tolerance);
                },
                error: (err) => {
                    tokenRenewListener.onException(err);
                    clearTimeout(this.timeoutId);
                }
            });
        }, timeout);
    }
    renew(token) {
        return token ?
            this.httpClient.get(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/jwt/renew`, { headers: { 'Authorization': 'Bearer ' + token }, observe: 'response' })
            : this.httpClient.get(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/jwt/renew`, { observe: 'response' });
    }
}
AuthService.ROOT_PATH = '/auth';
AuthService.MIN_WAIT_TIME = 1000;
AuthService.TOLERANCE = 1000 * 60 * 5; // 5 minutes
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYXV0aG9yaXphdGlvbi1zZXJ2aWNlcy9zcmMvbGliL3NlcnZpY2VzL2F1dGguc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFRcEMsTUFBTSxPQUFPLFdBQVc7SUFNdEIsWUFBb0IsUUFBa0IsRUFBVSxVQUFzQjtRQUFsRCxhQUFRLEdBQVIsUUFBUSxDQUFVO1FBQVUsZUFBVSxHQUFWLFVBQVUsQ0FBWTtJQUFJLENBQUM7SUFDcEUsTUFBTTtRQUNYLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxHQUFHLFdBQVcsQ0FBQyxTQUFTLFdBQVcsQ0FBQyxDQUFDO0lBQ3hHLENBQUM7SUFDTSxHQUFHLENBQUMsSUFBVTtRQUNuQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsR0FBRyxXQUFXLENBQUMsU0FBUyxXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDN0csQ0FBQztJQUNNLE1BQU0sQ0FBQyxPQUEwQjtRQUN0QyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsR0FBRyxXQUFXLENBQUMsU0FBUyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDakgsQ0FBQztJQUNNLEtBQUssQ0FBQyxPQUFxQjtRQUNoQyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsR0FBRyxXQUFXLENBQUMsU0FBUyxlQUFlLEVBQUUsT0FBTyxFQUFFLEVB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LEVBQUUsR0FBRyxXQUFXLENBQUMsU0FBUyxZQUFZLEVBQUUsRUFBQyxPQUFPLEVBQUUsRUFBQyxlQUFlLEVBQUUsU0FBUyxHQUFHLEtBQUssRUFBQyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUMsQ0FBQztZQUMzSSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQ25CLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsR0FBRyxXQUFXLENBQUMsU0FBUyxZQUFZLEVBQUUsRUFBQyxPQUFPLEVBQUUsVUFBVSxFQUFDLENBQUMsQ0FBQztJQUNqRyxDQUFDOztBQTFGc0IscUJBQVMsR0FBVyxPQUFPLENBQUM7QUFDM0IseUJBQWEsR0FBVyxJQUFJLENBQUM7QUFDN0IscUJBQVMsR0FBVyxJQUFJLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0h0dHBDbGllbnQsIEh0dHBSZXNwb25zZX0gZnJvbSBcIkBhbmd1bGFyL2NvbW1vbi9odHRwXCI7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQge1VzZXJ9IGZyb20gXCIuLi9tb2RlbHMvdXNlclwiO1xuaW1wb3J0IHtDcmVhdGVVc2VyUmVxdWVzdH0gZnJvbSBcIi4uL21vZGVscy9jcmVhdGUtdXNlci1yZXF1ZXN0XCI7XG5pbXBvcnQge0xvZ2luUmVxdWVzdH0gZnJvbSBcIi4uL21vZGVscy9sb2dpbi1yZXF1ZXN0XCI7XG5pbXBvcnQge1Bhc3N3b3JkUmVxdWVzdH0gZnJvbSBcIi4uL21vZGVscy9wYXNzd29yZC1yZXF1ZXN0XCI7XG5pbXBvcnQge1Rva2VuUmVuZXdMaXN0ZW5lcn0gZnJvbSBcIi4vdG9rZW4tcmVuZXdcIjtcbmltcG9ydCB7QXV0aENhbGxzfSBmcm9tIFwiLi9hdXRoLWNhbGxzXCI7XG5pbXBvcnQge1Jvb3RQYXRofSBmcm9tIFwiLi4vbW9kZWxzL3Jvb3QtcGF0aFwiO1xuXG5leHBvcnQgY2xhc3MgQXV0aFNlcnZpY2UgaW1wbGVtZW50cyBBdXRoQ2FsbHMge1xuXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUk9PVF9QQVRIOiBzdHJpbmcgPSAnL2F1dGgnO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBNSU5fV0FJVF9USU1FOiBudW1iZXIgPSAxMDAwO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBUT0xFUkFOQ0U6IG51bWJlciA9IDEwMDAgKiA2MCAqIDU7IC8vIDUgbWludXRlc1xuICBwcml2YXRlIHRpbWVvdXRJZDogbnVtYmVyO1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJvb3RQYXRoOiBSb290UGF0aCwgcHJpdmF0ZSBodHRwQ2xpZW50OiBIdHRwQ2xpZW50KSB7IH1cbiAgcHVibGljIGdldEFsbCgpOiBPYnNlcnZhYmxlPFVzZXJbXT4ge1xuICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQuZ2V0PFVzZXJbXT4oYCR7dGhpcy5yb290UGF0aC5nZXRSb290UGF0aCgpfSR7QXV0aFNlcnZpY2UuUk9PVF9QQVRIfS9yZWdpc3RlcmApO1xuICB9XG4gIHB1YmxpYyBhZGQodXNlcjogVXNlcik6IE9ic2VydmFibGU8VXNlcj4ge1xuICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQucG9zdDxVc2VyPihgJHt0aGlzLnJvb3RQYXRoLmdldFJvb3RQYXRoKCl9JHtBdXRoU2VydmljZS5ST09UX1BBVEh9L3JlZ2lzdGVyYCwgdXNlcik7XG4gIH1cbiAgcHVibGljIHVwZGF0ZShyZXF1ZXN0OiBDcmVhdGVVc2VyUmVxdWVzdCk6IE9ic2VydmFibGU8VXNlcj4ge1xuICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQucGF0Y2g8VXNlcj4oYCR7dGhpcy5yb290UGF0aC5nZXRSb290UGF0aCgpfSR7QXV0aFNlcnZpY2UuUk9PVF9QQVRIfS9yZWdpc3RlcmAsIHJlcXVlc3QpO1xuICB9XG4gIHB1YmxpYyBsb2dpbihyZXF1ZXN0OiBMb2dpblJlcXVlc3QpOiBPYnNlcnZhYmxlPEh0dHBSZXNwb25zZTxVc2VyPj4ge1xuICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQucG9zdDxVc2VyPihgJHt0aGlzLnJvb3RQYXRoLmdldFJvb3RQYXRoKCl9JHtBdXRoU2VydmljZS5ST09UX1BBVEh9L3B1YmxpYy9sb2dpbmAsIHJlcXVlc3QsIHtvYnNlcnZlOiAncmVzcG9uc2UnfSk7XG4gIH1cbiAgcHVibGljIGNoYW5nZVBhc3N3b3JkKHJlcXVlc3Q6IFBhc3N3b3JkUmVxdWVzdCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmh0dHBDbGllbnQucG9zdDx2b2lkPihgJHt0aGlzLnJvb3RQYXRoLmdldFJvb3RQYXRoKCl9JHtBdXRoU2VydmljZS5ST09UX1BBVEh9L3Bhc3N3b3JkYCwgcmVxdWVzdCk7XG4gIH1cbiAgcHVibGljIGdldFJvbGVzKCk6IE9ic2VydmFibGU8c3RyaW5nW10+IHtcbiAgICByZXR1cm4gdGhpcy5odHRwQ2xpZW50LmdldDxzdHJpbmdbXT4oYCR7dGhpcy5yb290UGF0aC5nZXRSb290UGF0aCgpfSR7QXV0aFNlcnZpY2UuUk9PVF9QQVRIfS9yb2xlc2ApO1xuICB9XG4gIHB1YmxpYyBkZWxldGVCeVVzZXJOYW1lKHVzZXJuYW1lOiBzdHJpbmcpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5odHRwQ2xpZW50LmRlbGV0ZTx2b2lkPihgJHt0aGlzLnJvb3RQYXRoLmdldFJvb3RQYXRoKCl9JHtBdXRoU2VydmljZS5ST09UX1BBVEh9L3JlZ2lzdGVyLyR7dXNlcm5hbWV9YCk7XG4gIH1cbiAgcHVibGljIGNhbmNlbEF1dG9SZW5ldygpOiB2b2lkIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICB9XG4gIHB1YmxpYyBsb2dpbkJ5VG9rZW4odG9rZW46IHN0cmluZyk6IE9ic2VydmFibGU8SHR0cFJlc3BvbnNlPFVzZXI+PiB7XG4gICAgcmV0dXJuIHRoaXMuaHR0cENsaWVudC5nZXQ8VXNlcj4oYCR7dGhpcy5yb290UGF0aC5nZXRSb290UGF0aCgpfSR7QXV0aFNlcnZpY2UuUk9PVF9QQVRIfS9wdWJsaWMvbG9naW4vdG9rZW5zLyR7dG9rZW59YCwge29ic2VydmU6ICdyZXNwb25zZSd9KTtcbiAgfVxuICBwdWJsaWMgYXV0b1JlbmV3VG9rZW4odG9rZW46IHN0cmluZywgZXhwaXJhdGlvbjogbnVtYmVyLCB0b2tlblJlbmV3TGlzdGVuZXI6IFRva2VuUmVuZXdMaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvbGVyYW5jZTogbnVtYmVyID0gQXV0aFNlcnZpY2UuVE9MRVJBTkNFKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudGltZW91dElkICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICB0aGlzLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4cGlyYXRpb25EYXRlOiBEYXRlID0gbmV3IERhdGUoZXhwaXJhdGlvbik7XG4gICAgY29uc3Qgbm93OiBEYXRlID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBleHBpcmF0aW9uVGltZTogbnVtYmVyID0gZXhwaXJhdGlvbkRhdGUuZ2V0VGltZSgpIC0gQXV0aFNlcnZpY2UuVE9MRVJBTkNFIC0gbm93LmdldFRpbWUoKTtcbiAgICB0aGlzLnNldFRpbWVvdXRSZW5ldyh0b2tlbiwgZXhwaXJhdGlvblRpbWUsIHRva2VuUmVuZXdMaXN0ZW5lciwgdG9sZXJhbmNlKTtcbiAgICBjb25zb2xlLmxvZyhgTmV4dCB0b2tlbiByZW5ldyBvbjogJHtleHBpcmF0aW9uRGF0ZX1gKTtcbiAgfVxuICBwcml2YXRlIHNldFRpbWVvdXRSZW5ldyh0b2tlbjogc3RyaW5nLCB0aW1lb3V0OiBudW1iZXIsIHRva2VuUmVuZXdMaXN0ZW5lcjogVG9rZW5SZW5ld0xpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b2xlcmFuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIGlmIChpc05hTih0aW1lb3V0KSkge1xuICAgICAgY29uc29sZS5lcnJvcihgVGltZW91dCBzaG91bGQgYmUgYSBudW1iZXIgYW5kIHJlY2VpdmVkICcke3RpbWVvdXR9J2ApXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aW1lb3V0IDwgQXV0aFNlcnZpY2UuTUlOX1dBSVRfVElNRSkge1xuICAgICAgdGltZW91dCA9IEF1dGhTZXJ2aWNlLk1JTl9XQUlUX1RJTUU7XG4gICAgfVxuICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCgoKTogdm9pZCA9PiB7XG4gICAgICB0aGlzLnJlbmV3KHRva2VuKS5zdWJzY3JpYmUoXG4gICAgICAgIHtcbiAgICAgICAgICBuZXh0OiAocmVzOiBIdHRwUmVzcG9uc2U8VXNlcj4pOiB2b2lkID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NlcnZlciByZXR1cm5lZCBpbnZhbGlkIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dGhUb2tlbjogc3RyaW5nID0gcmVzLmhlYWRlcnMuZ2V0KCdhdXRob3JpemF0aW9uJyk7XG4gICAgICAgICAgICBjb25zdCBleHBpcmF0aW9uOiBudW1iZXIgPSBOdW1iZXIocmVzLmhlYWRlcnMuZ2V0KCdleHBpcmVzJykpO1xuICAgICAgICAgICAgY29uc3QgdXNlcjogVXNlciA9IFVzZXIuY2xvbmUocmVzLmJvZHkpO1xuICAgICAgICAgICAgaWYgKCFhdXRoVG9rZW4gfHwgIWV4cGlyYXRpb24pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgcmV0dXJuZWQgaW52YWxpZCByZXNwb25zZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKGV4cGlyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIHJldHVybmVkIGludmFsaWQgZXhwaXJhdGlvbiB0aW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTmV4dCB0b2tlbiByZW5ldyBvbjogJHtuZXcgRGF0ZShleHBpcmF0aW9uKX1gKTtcbiAgICAgICAgICAgIHRva2VuUmVuZXdMaXN0ZW5lci5vblRva2VuUmVjZWl2ZWQoYXV0aFRva2VuLCBleHBpcmF0aW9uLCB1c2VyKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RpbWVPdXQ6IG51bWJlciA9IGV4cGlyYXRpb24gLSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRvbGVyYW5jZTtcbiAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dFJlbmV3KGF1dGhUb2tlbiwgbmV3VGltZU91dCwgdG9rZW5SZW5ld0xpc3RlbmVyLCB0b2xlcmFuY2UpO1xuXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogKGVycjogYW55KTogdm9pZCA9PiB7XG4gICAgICAgICAgICB0b2tlblJlbmV3TGlzdGVuZXIub25FeGNlcHRpb24oZXJyKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgfSwgdGltZW91dClcbiAgfVxuICBwdWJsaWMgcmVuZXcodG9rZW4gPzogc3RyaW5nKTogT2JzZXJ2YWJsZTxIdHRwUmVzcG9uc2U8VXNlcj4+IHtcbiAgICByZXR1cm4gdG9rZW4gP1xuICAgICAgdGhpcy5odHRwQ2xpZW50LmdldDxVc2VyPihcbiAgICAgICAgYCR7dGhpcy5yb290UGF0aC5nZXRSb290UGF0aCgpfSR7QXV0aFNlcnZpY2UuUk9PVF9QQVRIfS9qd3QvcmVuZXdgLCB7aGVhZGVyczogeydBdXRob3JpemF0aW9uJzogJ0JlYXJlciAnICsgdG9rZW59LCBvYnNlcnZlOiAncmVzcG9uc2UnfSlcbiAgICAgIDogdGhpcy5odHRwQ2xpZW50LmdldDxVc2VyPihcbiAgICAgICAgYCR7dGhpcy5yb290UGF0aC5nZXRSb290UGF0aCgpfSR7QXV0aFNlcnZpY2UuUk9PVF9QQVRIfS9qd3QvcmVuZXdgLCB7b2JzZXJ2ZTogJ3Jlc3BvbnNlJ30pO1xuICB9XG59XG4iXX0=