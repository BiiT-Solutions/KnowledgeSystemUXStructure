class CreatedElementDto {
    static clone(from) {
        const to = new CreatedElementDto();
        CreatedElementDto.copy(from, to);
        return to;
    }
    static copy(from, to) {
        to.createdAt = from.createdAt ? new Date(from.createdAt) : null;
        to.createdBy = from.createdBy;
        to.createdOn = from.createdOn;
    }
}

class ElementDto extends CreatedElementDto {
    static clone(from) {
        const to = new ElementDto();
        ElementDto.copy(from, to);
        return to;
    }
    static copy(from, to) {
        super.copy(from, to);
        to.id = from.id;
        to.updatedAt = from.updatedAt ? new Date(from.updatedAt) : null;
        to.updatedBy = from.updatedBy;
    }
}

class User extends ElementDto {
    static clone(from) {
        const to = new User();
        User.copy(from, to);
        return to;
    }
    static copy(from, to) {
        super.copy(from, to);
        to.idCard = from.idCard;
        to.uuid = from.uuid;
        to.username = from.username;
        to.name = from.name;
        to.lastname = from.lastname;
        to.email = from.email;
        to.phone = from.phone;
        to.languageId = from.languageId;
        to.password = from.password;
        to.passwordModifiedDate = from.passwordModifiedDate ? new Date(from.passwordModifiedDate) : null;
        to.accountExpirationTime = from.accountExpirationTime ? new Date(from.accountExpirationTime) : null;
        to.accountLocked = from.accountLocked;
        to.accountBlocked = from.accountBlocked;
        to.enabled = from.enabled;
        to.city = from.city;
        to.address = from.address;
        to.country = from.country;
        to.grantedAuthorities = from.grantedAuthorities;
        to.applicationRoles = from.applicationRoles;
    }
}

class AuthService {
    constructor(rootPath, httpClient) {
        this.rootPath = rootPath;
        this.httpClient = httpClient;
    }
    getAll() {
        return this.httpClient.get(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/register`);
    }
    add(user) {
        return this.httpClient.post(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/register`, user);
    }
    update(request) {
        return this.httpClient.patch(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/register`, request);
    }
    login(request) {
        return this.httpClient.post(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/public/login`, request, { observe: 'response' });
    }
    changePassword(request) {
        return this.httpClient.post(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/password`, request);
    }
    getRoles() {
        return this.httpClient.get(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/roles`);
    }
    deleteByUserName(username) {
        return this.httpClient.delete(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/register/${username}`);
    }
    cancelAutoRenew() {
        clearTimeout(this.timeoutId);
    }
    loginByToken(token) {
        return this.httpClient.get(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/public/login/tokens/${token}`, { observe: 'response' });
    }
    autoRenewToken(token, expiration, tokenRenewListener, tolerance = AuthService.TOLERANCE) {
        if (this.timeoutId != null) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        const expirationDate = new Date(expiration);
        const now = new Date();
        const expirationTime = expirationDate.getTime() - AuthService.TOLERANCE - now.getTime();
        this.setTimeoutRenew(token, expirationTime, tokenRenewListener, tolerance);
        console.log(`Next token renew on: ${expirationDate}`);
    }
    setTimeoutRenew(token, timeout, tokenRenewListener, tolerance) {
        if (isNaN(timeout)) {
            console.error(`Timeout should be a number and received '${timeout}'`);
            return;
        }
        if (timeout < AuthService.MIN_WAIT_TIME) {
            timeout = AuthService.MIN_WAIT_TIME;
        }
        this.timeoutId = setTimeout(() => {
            this.renew(token).subscribe({
                next: (res) => {
                    if (!res) {
                        console.error('Server returned invalid response');
                        return;
                    }
                    const authToken = res.headers.get('authorization');
                    const expiration = Number(res.headers.get('expires'));
                    const user = User.clone(res.body);
                    if (!authToken || !expiration) {
                        throw new Error('Server returned invalid response');
                    }
                    if (isNaN(expiration)) {
                        throw new Error('Server returned invalid expiration time');
                    }
                    console.log(`Next token renew on: ${new Date(expiration)}`);
                    tokenRenewListener.onTokenReceived(authToken, expiration, user);
                    const newTimeOut = expiration - new Date().getTime() - tolerance;
                    this.setTimeoutRenew(authToken, newTimeOut, tokenRenewListener, tolerance);
                },
                error: (err) => {
                    tokenRenewListener.onException(err);
                    clearTimeout(this.timeoutId);
                }
            });
        }, timeout);
    }
    renew(token) {
        return token ?
            this.httpClient.get(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/jwt/renew`, { headers: { 'Authorization': 'Bearer ' + token }, observe: 'response' })
            : this.httpClient.get(`${this.rootPath.getRootPath()}${AuthService.ROOT_PATH}/jwt/renew`, { observe: 'response' });
    }
}
AuthService.ROOT_PATH = '/auth';
AuthService.MIN_WAIT_TIME = 1000;
AuthService.TOLERANCE = 1000 * 60 * 5; // 5 minutes

class CreateUserRequest {
    static copy(from, to) {
        to.uniqueId = from.uniqueId;
        to.username = from.username;
        to.firstname = from.firstname;
        to.lastname = from.lastname;
        to.password = from.password;
        to.fullname = from.fullname;
        to.authorities = from.authorities;
    }
    static clone(from) {
        const to = new CreateUserRequest();
        CreateUserRequest.copy(from, to);
        return to;
    }
}

class LoginRequest {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
}

class PasswordRequest {
    constructor(oldPassword, newPassword) {
        this.oldPassword = oldPassword;
        this.newPassword = newPassword;
    }
}

var Role;
(function (Role) {
    Role["APPOINTMENTCENTER_ADMIN"] = "APPOINTMENTCENTER_ADMIN";
    Role["APPOINTMENTCENTER_EDITOR"] = "APPOINTMENTCENTER_EDITOR";
    Role["APPOINTMENTCENTER_VIEWER"] = "APPOINTMENTCENTER_VIEWER";
    Role["BASEFORMDROOLSENGINE_ADMIN"] = "BASEFORMDROOLSENGINE_ADMIN";
    Role["BASEFORMDROOLSENGINE_EDITOR"] = "BASEFORMDROOLSENGINE_EDITOR";
    Role["BASEFORMDROOLSENGINE_VIEWER"] = "BASEFORMDROOLSENGINE_VIEWER";
    Role["INFOGRAPHICENGINE_ADMIN"] = "INFOGRAPHICENGINE_ADMIN";
    Role["INFOGRAPHICENGINE_EDITOR"] = "INFOGRAPHICENGINE_EDITOR";
    Role["INFOGRAPHICENGINE_PRACTITIONER"] = "INFOGRAPHICENGINE_PRACTITIONER";
    Role["INFOGRAPHICENGINE_VIEWER"] = "INFOGRAPHICENGINE_VIEWER";
    Role["KAFKAPROXY_ADMIN"] = "KAFKAPROXY_ADMIN";
    Role["KAFKAPROXY_EDITOR"] = "KAFKAPROXY_EDITOR";
    Role["KAFKAPROXY_VIEWER"] = "KAFKAPROXY_VIEWER";
    Role["KNOWLEDGESYSTEM_ADMIN"] = "KNOWLEDGESYSTEM_ADMIN";
    Role["KNOWLEDGESYSTEM_EDITOR"] = "KNOWLEDGESYSTEM_EDITOR";
    Role["KNOWLEDGESYSTEM_VIEWER"] = "KNOWLEDGESYSTEM_VIEWER";
    Role["FACTMANAGER_ADMIN"] = "FACTMANAGER_ADMIN";
    Role["FACTMANAGER_EDITOR"] = "FACTMANAGER_EDITOR";
    Role["FACTMANAGER_VIEWER"] = "FACTMANAGER_VIEWER";
    Role["FACTSDASHBOARD_ADMIN"] = "FACTSDASHBOARD_ADMIN";
    Role["FACTSDASHBOARD_VIEWER"] = "FACTSDASHBOARD_VIEWER";
    Role["FACTSDASHBOARD_CEO"] = "FACTSDASHBOARD_CEO";
    Role["FACTSDASHBOARD_TEAMLEADER"] = "FACTSDASHBOARD_TEAMLEADER";
    Role["FACTSDASHBOARD_EMPLOYEE"] = "FACTSDASHBOARD_EMPLOYEE";
    Role["FACTSDASHBOARD_PRACTITIONER"] = "FACTSDASHBOARD_PRACTITIONER";
    Role["FACTSDASHBOARD_NCA"] = "FACTSDASHBOARD_NCA";
    Role["FACTSDASHBOARD_CADT"] = "FACTSDASHBOARD_CADT";
    Role["FACTSDASHBOARD_CREDIBILITY"] = "FACTSDASHBOARD_CREDIBILITY";
    Role["FACTSDASHBOARD_CUSTOMERLIST"] = "FACTSDASHBOARD_CUSTOMER LIST";
    Role["FACTSDASHBOARD_HAPPINESSATWORK"] = "FACTSDASHBOARD_HAPPINESS AT WORK";
    Role["FACTSDASHBOARD_FRUSTRATIONONTEAMWORKING"] = "FACTSDASHBOARD_FRUSTRATION ON TEAMWORKING";
    Role["FACTSDASHBOARD_ORGANIZATIONLIST"] = "FACTSDASHBOARD_ORGANIZATION LIST";
    Role["FACTSDASHBOARD_XLSACCESS"] = "FACTSDASHBOARD_XLS ACCESS";
    Role["PROFILEMATCHER_ADMIN"] = "PROFILEMATCHER_ADMIN";
    Role["PROFILEMATCHER_EDITOR"] = "PROFILEMATCHER_EDITOR";
    Role["PROFILEMATCHER_VIEWER"] = "PROFILEMATCHER_VIEWER";
    Role["TASKJUNCTION_ADMIN"] = "TASKJUNCTION_ADMIN";
    Role["TASKJUNCTION_EDITOR"] = "TASKJUNCTION_EDITOR";
    Role["TASKJUNCTION_VIEWER"] = "TASKJUNCTION_VIEWER";
    Role["USERMANAGERSYSTEM_ADMIN"] = "USERMANAGERSYSTEM_ADMIN";
    Role["USERMANAGERSYSTEM_EDITOR"] = "USERMANAGERSYSTEM_EDITOR";
    Role["USERMANAGERSYSTEM_VIEWER"] = "USERMANAGERSYSTEM_VIEWER";
    Role["USERMANAGERSYSTEM_ORGANIZATION_ADMIN"] = "USERMANAGERSYSTEM_ORGANIZATION_ADMIN";
    Role["FACTSDASHBOARD_ORGANIZATION_ADMIN"] = "FACTSDASHBOARD_ORGANIZATION_ADMIN";
    Role["PROFILEMATCHER_ORGANIZATION_ADMIN"] = "PROFILEMATCHER_ORGANIZATION_ADMIN";
})(Role || (Role = {}));

var AppRole;
(function (AppRole) {
    AppRole["APPOINTMENTCENTER_ADMIN"] = "APPOINTMENTCENTER_ADMIN";
    AppRole["APPOINTMENTCENTER_MANAGER"] = "APPOINTMENTCENTER_MANAGER";
    AppRole["APPOINTMENTCENTER_USER"] = "APPOINTMENTCENTER_USER";
    AppRole["BASEFORMDROOLSENGINE_ADMIN"] = "BASEFORMDROOLSENGINE_ADMIN";
    AppRole["BASEFORMDROOLSENGINE_USER"] = "BASEFORMDROOLSENGINE_USER";
    AppRole["FACTMANAGER_ADMIN"] = "FACTMANAGER_ADMIN";
    AppRole["FACTSDASHBOARD_CEO"] = "FACTSDASHBOARD_CEO";
    AppRole["FACTMANAGER_USER"] = "FACTMANAGER_USER";
    AppRole["INFOGRAPHICENGINE_ADMIN"] = "INFOGRAPHICENGINE_ADMIN";
    AppRole["INFOGRAPHICENGINE_USER"] = "INFOGRAPHICENGINE_USER";
    AppRole["KAFKAPROXY_ADMIN"] = "KAFKAPROXY_ADMIN";
    AppRole["KAFKAPROXY_USER"] = "KAFKAPROXY_USER";
    AppRole["KNOWLEDGESYSTEM_ADMIN"] = "KNOWLEDGESYSTEM_ADMIN";
    AppRole["KNOWLEDGESYSTEM_USER"] = "KNOWLEDGESYSTEM_USER";
    AppRole["PROFILEMATCHER_ADMIN"] = "PROFILEMATCHER_ADMIN";
    AppRole["PROFILEMATCHER_MANAGER"] = "PROFILEMATCHER_MANAGER";
    AppRole["PROFILEMATCHER_USER"] = "PROFILEMATCHER_USER";
    AppRole["TASKJUNCTION_ADMIN"] = "TASKJUNCTION_ADMIN";
    AppRole["TASKJUNCTION_USER"] = "TASKJUNCTION_USER";
    AppRole["USERMANAGERSYSTEM_ADMIN"] = "USERMANAGERSYSTEM_ADMIN";
    AppRole["USERMANAGERSYSTEM_EDITOR"] = "USERMANAGERSYSTEM_EDITOR";
    AppRole["USERMANAGERSYSTEM_ORGANIZATION_ADMIN"] = "USERMANAGERSYSTEM_ORGANIZATION_ADMIN";
    AppRole["USERMANAGERSYSTEM_USER"] = "USERMANAGERSYSTEM_USER";
    AppRole["PROFILEMATCHER_ORGANIZATION_ADMIN"] = "PROFILEMATCHER_ORGANIZATION_ADMIN";
})(AppRole || (AppRole = {}));

var _a;
class Constants {
}
Constants.SESSION_STORAGE = (_a = class {
},
    _a.AUTH_TOKEN = 'authToken',
    _a.AUTH_EXPIRATION = 'authExp',
    _a.USER = 'user',
    _a.PERMISSIONS = 'permissions',
    _a);

class SessionService {
    constructor(authService, context = '') {
        this.authService = authService;
        this.context = context;
        this.loggedIn = false;
        const authToken = localStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_TOKEN}`);
        const expires = +localStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`);
        let user = localStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.USER}`) ? User.clone(JSON.parse(localStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.USER}`))) : undefined;
        if (!user) {
            user = sessionStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.USER}`) ? User.clone(JSON.parse(sessionStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.USER}`))) : undefined;
        }
        this.user = user;
        if (!expires || isNaN(expires) || expires < new Date().getTime()) {
            localStorage.removeItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_TOKEN}`);
            localStorage.removeItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`);
            localStorage.removeItem(`${this.context}.${Constants.SESSION_STORAGE.USER}`);
        }
        if (authToken) {
            sessionStorage.setItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_TOKEN}`, authToken);
            sessionStorage.setItem(`${this.context}.${Constants.SESSION_STORAGE.USER}`, JSON.stringify(user));
            this.store = true;
            if (expires && !isNaN(expires)) {
                sessionStorage.setItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`, expires.toString());
            }
            this.loggedIn = true;
        }
        if ((authToken && expires)
            || (sessionStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_TOKEN}`) && sessionStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`))) {
            this.setAutoRenew(authToken ? authToken : sessionStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_TOKEN}`), expires ? expires : +sessionStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`));
        }
    }
    onTokenReceived(token, expiration, user) {
        this.setToken(token, expiration);
        this.setUser(user);
        console.log(`Token ${this.context ? 'for' + this.context : ''} has been renewed successfully.`, token);
    }
    onException(error) {
        console.error(`There was an exception while renewing the token ${this.context ? 'for' + this.context : ''}.`);
        this.clearToken();
    }
    setAutoRenew(token, expires) {
        // ADD HERE ALL SERVICES NEED TO BE CALLED TO RENEW TOKEN
        this.authService.autoRenewToken(token, expires, this);
    }
    clearToken() {
        sessionStorage.removeItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_TOKEN}`);
        sessionStorage.removeItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`);
        sessionStorage.removeItem(`${this.context}.${Constants.SESSION_STORAGE.USER}`);
        this.store = undefined;
        localStorage.removeItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_TOKEN}`);
        localStorage.removeItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`);
        localStorage.removeItem(`${this.context}.${Constants.SESSION_STORAGE.USER}`);
        this.loggedIn = false;
        this.user = undefined;
    }
    setToken(token, expires, enableStore = undefined, autoRenew = false) {
        if (!token || !expires) {
            this.clearToken();
            return;
        }
        sessionStorage.setItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_TOKEN}`, token);
        sessionStorage.setItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`, expires.toString());
        if (enableStore !== undefined) {
            this.store = enableStore;
            if (!enableStore) {
                localStorage.removeItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_TOKEN}`);
                localStorage.removeItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`);
            }
        }
        if (this.store) {
            localStorage.setItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_TOKEN}`, token);
            localStorage.setItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`, expires.toString());
        }
        if (autoRenew) {
            this.setAutoRenew(token, expires);
        }
        this.loggedIn = true;
    }
    getToken() {
        return sessionStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_TOKEN}`);
    }
    isTokenExpired() {
        const expired = !sessionStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`) ||
            new Date().getTime() > +sessionStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`) || !this.getToken();
        if (!expired) {
            this.loggedIn = true;
        }
        return expired;
    }
    getExpirationDate() {
        const sessionExpiration = sessionStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`);
        if (!isNaN(+sessionExpiration)) {
            return new Date(+sessionStorage.getItem(`${this.context}.${Constants.SESSION_STORAGE.AUTH_EXPIRATION}`));
        }
        return null;
    }
    get isLoggedIn() {
        return this.loggedIn;
    }
    setUser(user, enableStore = undefined) {
        sessionStorage.setItem(`${this.context}.${Constants.SESSION_STORAGE.USER}`, JSON.stringify(user));
        if (enableStore !== undefined) {
            if (!enableStore) {
                localStorage.removeItem(`${this.context}.${Constants.SESSION_STORAGE.USER}`);
            }
        }
        if (this.store) {
            localStorage.setItem(`${this.context}.${Constants.SESSION_STORAGE.USER}`, JSON.stringify(user));
        }
        this.user = user;
    }
    getUser() {
        return this.user;
    }
}

/*
 * Public API Surface of authorization-services
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AppRole, AuthService, CreateUserRequest, CreatedElementDto, ElementDto, LoginRequest, PasswordRequest, Role, SessionService, User };
//# sourceMappingURL=biit-solutions-authorization-services.mjs.map
